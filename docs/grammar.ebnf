(* ================================================================== *)
(* Moxy Language — Formal EBNF Grammar Specification                  *)
(*                                                                    *)
(* Moxy is a C superset that transpiles .mxy source files to C.       *)
(* This grammar documents the complete syntax accepted by the parser.  *)
(* ================================================================== *)


(* ------------------------------------------------------------------ *)
(* 1. Program Structure                                               *)
(* ------------------------------------------------------------------ *)

program
    = { top_level_decl } ;

top_level_decl
    = enum_decl
    | func_decl
    | global_var_decl
    | c_passthrough_toplevel ;


(* ------------------------------------------------------------------ *)
(* 2. Enum Declaration (Moxy tagged enums)                            *)
(* ------------------------------------------------------------------ *)

enum_decl
    = "enum" IDENT "{" variant_list "}" ;

variant_list
    = variant { "," variant } [ "," ] ;

variant
    = IDENT [ "(" field_list ")" ] ;

field_list
    = field { "," field } ;

field
    = type_name IDENT ;


(* ------------------------------------------------------------------ *)
(* 3. Function Declaration                                            *)
(* ------------------------------------------------------------------ *)

func_decl
    = type_name IDENT "(" [ param_list ] ")" block ;

param_list
    = param { "," param }
    | param { "," param } "," "..." ;

param
    = type_name IDENT [ "(" [ type_list ] ")" ]   (* function pointer param *)
    | "..." ;

type_list
    = type_name { "," type_name } ;


(* ------------------------------------------------------------------ *)
(* 4. Global Variable Declaration                                     *)
(* ------------------------------------------------------------------ *)

global_var_decl
    = type_name IDENT "=" expr ";" ;


(* ------------------------------------------------------------------ *)
(* 5. C Passthrough (top-level)                                       *)
(*    Includes typedefs, struct/union definitions, extern              *)
(*    declarations, C-style enums, and any other C constructs          *)
(*    not directly handled by the Moxy parser.                         *)
(* ------------------------------------------------------------------ *)

c_passthrough_toplevel
    = typedef_passthrough
    | struct_union_passthrough
    | extern_passthrough
    | c_enum_passthrough
    | raw_toplevel ;

typedef_passthrough
    = "typedef" c_tokens ";" ;

struct_union_passthrough
    = ( "struct" | "union" ) IDENT "{" c_tokens "}" [ ";" ] ;

extern_passthrough
    = "extern" c_tokens ";" ;

c_enum_passthrough
    = "enum" IDENT "{" c_enum_body "}" [ IDENT ] ";" ;

c_enum_body
    = IDENT [ "=" expr ] { "," IDENT [ "=" expr ] } [ "," ] ;


(* ------------------------------------------------------------------ *)
(* 6. Types                                                           *)
(* ------------------------------------------------------------------ *)

type_name
    = { type_qualifier } type_core { "*" } ;

type_qualifier
    = "const"
    | "volatile"
    | "static"
    | "extern"
    | "register"
    | "inline" ;

type_core
    = primitive_type
    | result_type
    | future_type
    | map_type
    | list_type
    | struct_union_type
    | signed_unsigned_type
    | long_type
    | IDENT ;

primitive_type
    = "string"
    | "int"
    | "float"
    | "double"
    | "char"
    | "bool"
    | "long"
    | "short"
    | "void" ;

result_type
    = "Result" "<" type_name ">" ;

future_type
    = "Future" "<" type_name ">" ;

map_type
    = "map" "[" type_name "," type_name "]" ;

list_type
    = primitive_type "[" "]"
    | IDENT "[" "]" ;

struct_union_type
    = ( "struct" | "union" | "enum" ) [ IDENT ] { "*" } ;

signed_unsigned_type
    = ( "unsigned" | "signed" ) [ "int" | "long" [ "long" ] | "short" | "char" ] { "*" } ;

long_type
    = "long" [ "long" | "double" | "int" ] { "*" } ;

function_pointer_type
    = type_name "(" "*" ")" "(" [ type_list ] ")" ;


(* ------------------------------------------------------------------ *)
(* 7. Statements                                                      *)
(* ------------------------------------------------------------------ *)

block
    = "{" { stmt } "}" ;

stmt
    = print_stmt
    | assert_stmt
    | match_stmt
    | if_stmt
    | while_stmt
    | for_stmt
    | for_in_stmt
    | return_stmt
    | var_decl_stmt
    | assign_stmt
    | expr_stmt
    | c_passthrough_stmt ;


(* 7.1 Print *)

print_stmt
    = "print" "(" expr ")" [ ";" ] ;


(* 7.2 Assert *)

assert_stmt
    = "assert" "(" expr ")" [ ";" ] ;


(* 7.3 Match *)

match_stmt
    = "match" IDENT "{" { match_arm [ "," ] } "}" ;

match_arm
    = pattern "=>" stmt ;

pattern
    = enum_pattern
    | result_pattern ;

enum_pattern
    = IDENT "::" IDENT [ "(" IDENT ")" ] ;

result_pattern
    = ( "Ok" | "Err" ) [ "(" IDENT ")" ] ;


(* 7.4 If / Else If / Else *)

if_stmt
    = "if" "(" expr ")" block [ "else" ( if_stmt | block ) ] ;


(* 7.5 While *)

while_stmt
    = "while" "(" expr ")" block ;


(* 7.6 For (C-style) *)

for_stmt
    = "for" "(" for_init ";" expr ";" for_step ")" block ;

for_init
    = type_name IDENT "=" expr
    | expr ;

for_step
    = expr [ assign_op expr ] ;


(* 7.7 For-in *)

for_in_stmt
    = "for" IDENT [ "," IDENT ] "in" for_in_iter block ;

for_in_iter
    = expr ".." expr                  (* range *)
    | expr ;                          (* collection or map *)


(* 7.8 Return *)

return_stmt
    = "return" [ expr ] ";" ;


(* 7.9 Variable Declaration (in statement position) *)

var_decl_stmt
    = type_name IDENT "=" expr ";" ;


(* 7.10 Assignment *)

assign_stmt
    = expr assign_op expr ";" ;

assign_op
    = "=" | "+=" | "-=" | "*=" | "/="
    | "&=" | "|=" | "^=" | "%="
    | "<<=" | ">>=" ;


(* 7.11 Expression Statement *)

expr_stmt
    = expr [ ";" ] ;


(* 7.12 C Passthrough Statements *)
(*      switch, do/while, goto, labels, break, continue,              *)
(*      typedef, struct, union, extern, register, volatile, inline    *)

c_passthrough_stmt
    = switch_stmt
    | do_while_stmt
    | goto_stmt
    | label_stmt
    | break_stmt
    | continue_stmt
    | case_label
    | default_label
    | raw_stmt ;

switch_stmt
    = "switch" "(" expr ")" "{" { c_tokens } "}" ;

do_while_stmt
    = "do" "{" { c_tokens } "}" "while" "(" expr ")" ";" ;

goto_stmt
    = "goto" IDENT ";" ;

label_stmt
    = IDENT ":" ;

break_stmt
    = "break" ";" ;

continue_stmt
    = "continue" ";" ;

case_label
    = "case" expr ":" ;

default_label
    = "default" ":" ;


(* ------------------------------------------------------------------ *)
(* 8. Expressions (by precedence, lowest to highest)                  *)
(* ------------------------------------------------------------------ *)

expr
    = ternary_expr ;

(* 8.1 Ternary — lowest precedence, right-associative *)

ternary_expr
    = pipe_expr [ "?" expr ":" ternary_expr ] ;

(* 8.2 Pipe — precedence 0 *)

pipe_expr
    = logical_or_expr { "|>" pipe_target } ;

pipe_target
    = IDENT "(" [ expr_list ] ")"     (* function call with args *)
    | IDENT [ "(" [ expr_list ] ")" ] (* bare ident or ident with parens *)
    | postfix_expr ;                  (* method call *)

(* 8.3 Logical OR — precedence 1 *)

logical_or_expr
    = logical_and_expr { "||" logical_and_expr } ;

(* 8.4 Logical AND — precedence 2 *)

logical_and_expr
    = bitwise_or_expr { "&&" bitwise_or_expr } ;

(* 8.5 Bitwise OR — precedence 3 *)

bitwise_or_expr
    = bitwise_xor_expr { "|" bitwise_xor_expr } ;

(* 8.6 Bitwise XOR — precedence 4 *)

bitwise_xor_expr
    = bitwise_and_expr { "^" bitwise_and_expr } ;

(* 8.7 Bitwise AND — precedence 5 *)

bitwise_and_expr
    = equality_expr { "&" equality_expr } ;

(* 8.8 Equality — precedence 6 *)

equality_expr
    = comparison_expr { ( "==" | "!=" ) comparison_expr } ;

(* 8.9 Comparison — precedence 7 *)

comparison_expr
    = shift_expr { ( "<" | ">" | "<=" | ">=" ) shift_expr } ;

(* 8.10 Shift — precedence 8 *)

shift_expr
    = additive_expr { ( "<<" | ">>" ) additive_expr } ;

(* 8.11 Additive — precedence 9 *)

additive_expr
    = multiplicative_expr { ( "+" | "-" ) multiplicative_expr } ;

(* 8.12 Multiplicative — precedence 10 *)

multiplicative_expr
    = unary_expr { ( "*" | "/" | "%" ) unary_expr } ;

(* 8.13 Unary Prefix — parsed by parse_primary *)

unary_expr
    = postfix_expr
    | prefix_op unary_expr ;

prefix_op
    = "-" | "!" | "~" | "&" | "*" | "++" | "--" ;

(* 8.14 Postfix *)

postfix_expr
    = primary_expr { postfix_op } ;

postfix_op
    = "." IDENT                       (* field access *)
    | "." IDENT "(" [ expr_list ] ")" (* method call *)
    | "->" IDENT                      (* arrow field access *)
    | "->" IDENT "(" [ expr_list ] ")"(* arrow method call *)
    | "[" expr "]"                    (* index *)
    | "++"                            (* postfix increment *)
    | "--" ;                          (* postfix decrement *)

expr_list
    = expr { "," expr } ;


(* ------------------------------------------------------------------ *)
(* 9. Primary Expressions                                             *)
(* ------------------------------------------------------------------ *)

primary_expr
    = lambda_expr
    | cast_expr
    | paren_expr
    | string_literal
    | integer_literal
    | float_literal
    | char_literal
    | bool_literal
    | null_literal
    | ok_expr
    | err_expr
    | list_literal
    | empty_literal
    | sizeof_expr
    | await_expr
    | enum_init_expr
    | call_expr
    | IDENT
    | brace_expr ;


(* 9.1 Lambda *)

lambda_expr
    = "(" [ typed_param_list ] ")" "=>" lambda_body ;

typed_param_list
    = type_name IDENT { "," type_name IDENT } ;

lambda_body
    = expr
    | block ;


(* 9.2 Cast *)

cast_expr
    = "(" c_type ")" primary_expr ;

c_type
    = c_type_keyword { c_type_keyword | "*" } ;

c_type_keyword
    = "int" | "char" | "float" | "double" | "void" | "long"
    | "short" | "bool" | "string"
    | "struct" | "union"
    | "unsigned" | "signed"
    | "const" | "volatile" | "enum" ;


(* 9.3 Parenthesized Expression *)

paren_expr
    = "(" expr ")" ;


(* 9.4 Ok / Err (Result constructors) *)

ok_expr
    = "Ok" "(" expr ")" ;

err_expr
    = "Err" "(" expr ")" ;


(* 9.5 List Literal *)

list_literal
    = "[" [ expr { "," expr } [ "," ] ] "]" ;


(* 9.6 Empty Literal (for map initialization) *)

empty_literal
    = "{" "}" ;


(* 9.7 Brace Expression *)
(*     Non-empty brace blocks in expression position are passed       *)
(*     through as raw C (e.g., compound literals, initializers).      *)

brace_expr
    = "{" c_tokens "}" ;


(* 9.8 Sizeof *)

sizeof_expr
    = "sizeof" "(" c_tokens ")" ;


(* 9.9 Await *)

await_expr
    = "await" postfix_expr ;


(* 9.10 Enum Initialization *)

enum_init_expr
    = IDENT "::" IDENT [ "(" [ expr_list ] ")" ] ;


(* 9.11 Function Call *)

call_expr
    = IDENT "(" [ expr_list ] ")" ;


(* ------------------------------------------------------------------ *)
(* 10. Preprocessor Directives                                        *)
(*     Handled before lexing by the preprocessor pass.                *)
(* ------------------------------------------------------------------ *)

preprocessor_directive
    = include_directive
    | c_directive ;

include_directive
    = "#include" '"' mxy_path '"'     (* inline .mxy file *)
    | "#include" "<" mxy_path ">"     (* inline from stdlib *)
    | "#include" '"' c_header '"'     (* pass through to C *)
    | "#include" "<" c_header ">" ;   (* pass through to C *)

mxy_path
    = path_string ;                   (* must end in ".mxy" *)

c_header
    = path_string ;                   (* does not end in ".mxy" *)

(* All other # directives are passed through verbatim to C output.    *)

c_directive
    = "#" directive_name { c_tokens } NEWLINE ;

directive_name
    = "define" | "ifdef" | "ifndef" | "endif" | "if" | "elif"
    | "else" | "undef" | "pragma" | "error" | "warning"
    | "line" ;


(* ------------------------------------------------------------------ *)
(* 11. Lexical Elements                                               *)
(* ------------------------------------------------------------------ *)

(* 11.1 Identifiers *)

IDENT
    = ( letter | "_" ) { letter | digit | "_" } ;

letter
    = "a" | ... | "z" | "A" | ... | "Z" ;

digit
    = "0" | ... | "9" ;

hex_digit
    = digit | "a" | ... | "f" | "A" | ... | "F" ;


(* 11.2 Integer Literals *)

integer_literal
    = decimal_literal [ integer_suffix ]
    | hex_literal [ integer_suffix ] ;

decimal_literal
    = digit { digit } ;

hex_literal
    = "0" ( "x" | "X" ) hex_digit { hex_digit } ;

integer_suffix
    = { "L" | "l" | "U" | "u" } ;


(* 11.3 Float Literals *)

float_literal
    = digit { digit } "." digit { digit } [ exponent ] [ float_suffix ]
    | digit { digit } exponent [ float_suffix ]
    | digit { digit } float_suffix ;

exponent
    = ( "e" | "E" ) [ "+" | "-" ] digit { digit } ;

float_suffix
    = "f" | "F" ;


(* 11.4 String Literals *)

string_literal
    = '"' { string_char } '"' ;

string_char
    = any_char - ( '"' | "\\" )
    | escape_sequence ;

escape_sequence
    = "\\" ( "n" | "t" | "r" | "\\" | '"' | "0" | "'" | "x" hex_digit hex_digit ) ;


(* 11.5 Character Literals *)

char_literal
    = "'" ( char_char | escape_sequence ) "'" ;

char_char
    = any_char - ( "'" | "\\" ) ;


(* 11.6 Boolean Literals *)

bool_literal
    = "true" | "false" ;


(* 11.7 Null Literals *)

null_literal
    = "null" | "NULL" ;


(* 11.8 Comments *)

line_comment
    = "//" { any_char } NEWLINE ;

block_comment
    = "/*" { any_char } "*/" ;


(* 11.9 Whitespace *)
(*      Spaces, tabs, newlines, and carriage returns are skipped.     *)
(*      Comments are treated as whitespace.                           *)


(* ------------------------------------------------------------------ *)
(* 12. Keywords                                                       *)
(* ------------------------------------------------------------------ *)

(* Moxy keywords — these have dedicated token kinds and are not IDENT *)

(* Type keywords:       string int float double char bool long short  *)
(*                      void                                          *)
(* Moxy keywords:       enum match true false Result map Ok Err       *)
(*                      if else for while return null in              *)
(*                      Future await                                  *)
(* C keywords:          struct union typedef switch case default do   *)
(*                      break continue sizeof static const extern     *)
(*                      unsigned signed goto volatile register inline *)
(*                      NULL                                          *)


(* ------------------------------------------------------------------ *)
(* 13. Operators                                                      *)
(* ------------------------------------------------------------------ *)

(* Single-character:  { } ( ) [ ] < > . , ; = + - * / % ! : ? & | ^ ~ *)
(* Two-character:     :: => == != << <= >> >= && &= || |> |= ^= %=    *)
(*                    -> += -= *= /= ++ -- ..                          *)
(* Three-character:   <<= >>= ...                                      *)


(* ------------------------------------------------------------------ *)
(* Auxiliary Definitions                                               *)
(* ------------------------------------------------------------------ *)

c_tokens
    = (* any balanced sequence of tokens — braces, parens, and        *)
      (* brackets are matched. Consumed verbatim and emitted as raw C. *) ;

raw_toplevel
    = c_tokens ( ";" | "}" ) ;

raw_stmt
    = c_tokens ( ";" | "}" ) ;

path_string
    = { any_char - ( '"' | ">" ) } ;

NEWLINE
    = "\n" ;
