/* AUTO-GENERATED by scripts/genstdlib.sh â€” do not edit */
#include <string.h>
#include "mxystdlib.h"

static const StdlibEntry stdlib_entries[] = {
    { "std/debug.mxy",
      "#include <stdio.h>\n"
      "#include <stdlib.h>\n"
      "\n"
      "void panic(string msg) {\n"
      "  fprintf(stderr, \"panic: %s\\n\", msg);\n"
      "  exit(1);\n"
      "}\n"
      "\n"
      "void todo(string msg) {\n"
      "  fprintf(stderr, \"todo: %s\\n\", msg);\n"
      "  exit(1);\n"
      "}\n"
      "\n"
      "void unreachable() {\n"
      "  fprintf(stderr, \"unreachable code reached\\n\");\n"
      "  exit(1);\n"
      "}\n"
    },
    { "std/io.mxy",
      "#include <stdio.h>\n"
      "#include <stdlib.h>\n"
      "\n"
      "void eprintln(string msg) {\n"
      "  fprintf(stderr, \"%s\\n\", msg);\n"
      "}\n"
      "\n"
      "string readln() {\n"
      "  char buf[1024];\n"
      "  if (fgets(buf, sizeof(buf), stdin) == NULL) {\n"
      "    return \"\";\n"
      "  }\n"
      "  int len = strlen(buf);\n"
      "  if (len > 0 && buf[len - 1] == '\\n') {\n"
      "    buf[len - 1] = '\\0';\n"
      "  }\n"
      "  return strdup(buf);\n"
      "}\n"
    },
    { "std/math.mxy",
      "int abs_int(int x) {\n"
      "  if (x < 0) { return -x; }\n"
      "  return x;\n"
      "}\n"
      "\n"
      "int min_int(int a, int b) {\n"
      "  if (a < b) { return a; }\n"
      "  return b;\n"
      "}\n"
      "\n"
      "int max_int(int a, int b) {\n"
      "  if (a > b) { return a; }\n"
      "  return b;\n"
      "}\n"
      "\n"
      "int clamp_int(int x, int lo, int hi) {\n"
      "  if (x < lo) { return lo; }\n"
      "  if (x > hi) { return hi; }\n"
      "  return x;\n"
      "}\n"
    },
    { "std/string.mxy",
      "#include <string.h>\n"
      "\n"
      "int str_len(string s) {\n"
      "  return strlen(s);\n"
      "}\n"
      "\n"
      "int str_eq(string a, string b) {\n"
      "  return strcmp(a, b) == 0;\n"
      "}\n"
      "\n"
      "int str_contains(string haystack, string needle) {\n"
      "  return strstr(haystack, needle) != NULL;\n"
      "}\n"
      "\n"
      "int str_starts_with(string s, string prefix) {\n"
      "  int plen = strlen(prefix);\n"
      "  return strncmp(s, prefix, plen) == 0;\n"
      "}\n"
      "\n"
      "int str_ends_with(string s, string suffix) {\n"
      "  int slen = strlen(s);\n"
      "  int suflen = strlen(suffix);\n"
      "  if (suflen > slen) { return 0; }\n"
      "  return strcmp(s + slen - suflen, suffix) == 0;\n"
      "}\n"
    },
    { "std/test.mxy",
      "#include <stdio.h>\n"
      "#include <stdlib.h>\n"
      "#include <string.h>\n"
      "\n"
      "void assert_eq_int(int a, int b) {\n"
      "  if (a != b) {\n"
      "    fprintf(stderr, \"assertion failed: %d != %d\\n\", a, b);\n"
      "    exit(1);\n"
      "  }\n"
      "}\n"
      "\n"
      "void assert_eq_str(string a, string b) {\n"
      "  if (strcmp(a, b) != 0) {\n"
      "    fprintf(stderr, \"assertion failed: \\\"%s\\\" != \\\"%s\\\"\\n\", a, b);\n"
      "    exit(1);\n"
      "  }\n"
      "}\n"
      "\n"
      "void assert_true(int cond) {\n"
      "  if (!cond) {\n"
      "    fprintf(stderr, \"assertion failed: expected true\\n\");\n"
      "    exit(1);\n"
      "  }\n"
      "}\n"
      "\n"
      "void assert_false(int cond) {\n"
      "  if (cond) {\n"
      "    fprintf(stderr, \"assertion failed: expected false\\n\");\n"
      "    exit(1);\n"
      "  }\n"
      "}\n"
    },
};

static const int stdlib_count = 5;

const char *stdlib_lookup(const char *path) {
    for (int i = 0; i < stdlib_count; i++)
        if (strcmp(stdlib_entries[i].path, path) == 0)
            return stdlib_entries[i].source;
    return NULL;
}
