// Mapper implementations (0 = NROM, 4 = MMC3)

void mapper_init() {
    if (mapper == 4) {
        mmc3_bank_select = 0;
        mmc3_prg_mode = 0;
        mmc3_chr_mode = 0;
        mmc3_irq_latch = 0;
        mmc3_irq_counter = 0;
        mmc3_irq_enabled = 0;
        mmc3_irq_reload = 0;
        mmc3_irq_pending = 0;
        memset(mmc3_banks, 0, 8);
    }
}

// PRG-ROM read for mapper 0
u8 mapper0_prg_read(u16 addr) {
    int offset = addr - 0x8000;
    if (prg_size <= 16384) {
        offset = offset & 0x3FFF;
    }
    return prg_rom_data[offset];
}

// PRG-ROM read for mapper 4 (MMC3)
u8 mapper4_prg_read(u16 addr) {
    int bank = 0;
    int offset = 0;
    int last_bank = (prg_size / 8192) - 1;
    int second_last = last_bank - 1;

    if (addr < 0xA000) {
        // $8000-$9FFF
        if (mmc3_prg_mode == 0) {
            bank = mmc3_banks[6] % (prg_size / 8192);
        } else {
            bank = second_last;
        }
        offset = addr - 0x8000;
    } else if (addr < 0xC000) {
        // $A000-$BFFF
        bank = mmc3_banks[7] % (prg_size / 8192);
        offset = addr - 0xA000;
    } else if (addr < 0xE000) {
        // $C000-$DFFF
        if (mmc3_prg_mode == 0) {
            bank = second_last;
        } else {
            bank = mmc3_banks[6] % (prg_size / 8192);
        }
        offset = addr - 0xC000;
    } else {
        // $E000-$FFFF
        bank = last_bank;
        offset = addr - 0xE000;
    }

    return prg_rom_data[bank * 8192 + offset];
}

u8 mapper_prg_read(u16 addr) {
    if (mapper == 4) {
        return mapper4_prg_read(addr);
    }
    return mapper0_prg_read(addr);
}

// CHR read for mapper 4 (MMC3)
u8 mapper4_chr_read(u16 addr) {
    if (chr_is_ram) {
        return chr_ram[addr & 0x1FFF];
    }

    int bank = 0;
    int offset = 0;
    int a = addr;

    if (mmc3_chr_mode == 0) {
        // Mode 0: 2KB banks at $0000/$0800, 1KB at $1000-$1C00
        if (a < 0x0800) {
            bank = (mmc3_banks[0] & 0xFE) % (chr_size / 1024);
            offset = a;
        } else if (a < 0x1000) {
            bank = (mmc3_banks[1] & 0xFE) % (chr_size / 1024);
            offset = a - 0x0800;
        } else if (a < 0x1400) {
            bank = mmc3_banks[2] % (chr_size / 1024);
            offset = a - 0x1000;
        } else if (a < 0x1800) {
            bank = mmc3_banks[3] % (chr_size / 1024);
            offset = a - 0x1400;
        } else if (a < 0x1C00) {
            bank = mmc3_banks[4] % (chr_size / 1024);
            offset = a - 0x1800;
        } else {
            bank = mmc3_banks[5] % (chr_size / 1024);
            offset = a - 0x1C00;
        }
    } else {
        // Mode 1: 1KB at $0000-$0C00, 2KB at $1000/$1800
        if (a < 0x0400) {
            bank = mmc3_banks[2] % (chr_size / 1024);
            offset = a;
        } else if (a < 0x0800) {
            bank = mmc3_banks[3] % (chr_size / 1024);
            offset = a - 0x0400;
        } else if (a < 0x0C00) {
            bank = mmc3_banks[4] % (chr_size / 1024);
            offset = a - 0x0800;
        } else if (a < 0x1000) {
            bank = mmc3_banks[5] % (chr_size / 1024);
            offset = a - 0x0C00;
        } else if (a < 0x1800) {
            bank = (mmc3_banks[0] & 0xFE) % (chr_size / 1024);
            offset = a - 0x1000;
        } else {
            bank = (mmc3_banks[1] & 0xFE) % (chr_size / 1024);
            offset = a - 0x1800;
        }
    }

    return chr_rom_data[bank * 1024 + offset];
}

// Mapper register writes ($8000-$FFFF)
void mapper_write(u16 addr, u8 val) {
    if (mapper == 0) {
        return;
    }

    // MMC3
    int a = addr;
    if (a < 0xA000) {
        if (a & 1) {
            // $8001 - bank data
            mmc3_banks[mmc3_bank_select & 0x07] = val;
        } else {
            // $8000 - bank select
            mmc3_bank_select = val;
            mmc3_prg_mode = (val >> 6) & 1;
            mmc3_chr_mode = (val >> 7) & 1;
        }
    } else if (a < 0xC000) {
        if (a & 1) {
            // $A001 - PRG RAM protect (ignored)
        } else {
            // $A000 - mirroring
            mirror_mode = (val & 1) ? 0 : 1; // 0=vertical, 1=horizontal (inverted from bit)
        }
    } else if (a < 0xE000) {
        if (a & 1) {
            // $C001 - IRQ reload
            mmc3_irq_counter = 0;
            mmc3_irq_reload = 1;
        } else {
            // $C000 - IRQ latch
            mmc3_irq_latch = val;
        }
    } else {
        if (a & 1) {
            // $E001 - IRQ enable
            mmc3_irq_enabled = 1;
        } else {
            // $E000 - IRQ disable + ack
            mmc3_irq_enabled = 0;
            mmc3_irq_pending = 0;
        }
    }
}

// Called on A12 rising edge (PPU scanline counter)
void mapper_scanline() {
    if (mapper != 4) {
        return;
    }
    if (mmc3_irq_counter == 0 || mmc3_irq_reload) {
        mmc3_irq_counter = mmc3_irq_latch;
        mmc3_irq_reload = 0;
    } else {
        mmc3_irq_counter--;
    }
    if (mmc3_irq_counter == 0 && mmc3_irq_enabled) {
        mmc3_irq_pending = 1;
    }
}
